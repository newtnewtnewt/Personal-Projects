/**   A class that implements the ADT deque by using a doubly linked chain of nodes.      @author Frank M. Carrano   @author Timothy M. Henry   @version 4.0*/public class LinkedDeque<T> implements DequeInterface<T>{   private DLNode firstNode; // References node at front of deque   private DLNode lastNode;  // References node at back of deque		public LinkedDeque()	{		firstNode = null;		lastNode = null;	} // end default constructor		public void clear()	{		firstNode = null;		lastNode = null;			} // end clear	public void addToBack(T newEntry)	{		if(isEmpty()) {			DLNode newNode = new DLNode(newEntry);			firstNode = newNode;			lastNode = newNode;			firstNode.next = lastNode;			lastNode.previous = firstNode;		}		else if(firstNode == lastNode) {			DLNode newNode = new DLNode(newEntry);			lastNode = newNode;			firstNode.next = lastNode;			lastNode.previous = firstNode;		}		else {			DLNode newNode = new DLNode(lastNode, newEntry, null);			lastNode.next = newNode;			lastNode = newNode;		}	} // end addToBack	public void addToFront(T newEntry)	{		if(isEmpty()) {			DLNode newNode = new DLNode(newEntry);			firstNode = newNode;			lastNode = newNode;			firstNode.next = lastNode;			lastNode.previous = firstNode;		}		else if(firstNode == lastNode) {			DLNode newNode = new DLNode(newEntry);			firstNode = newNode;			firstNode.next = lastNode;			lastNode.previous = firstNode;		}		else {			DLNode newNode = new DLNode(null, newEntry, firstNode);			firstNode.previous = newNode;			firstNode = newNode;		}	} // end addToFront   	public T getBack()	{		if(isEmpty()) {			throw new EmptyQueueException("The queue is empty");		}		return lastNode.data;	} // end getBack   	public T getFront()	{		if(isEmpty()) {			throw new EmptyQueueException("The queue is empty");		}		return firstNode.data;	} // end getFront	public T removeFront()	{		if(isEmpty()) {			throw new EmptyQueueException("The queue is empty");		}		T tempData = lastNode.data;		if(firstNode == lastNode) {			firstNode = null;			lastNode = null;			return tempData;					}		else {		firstNode = firstNode.next;		return tempData;		}	} // end removeFront			public T removeBack()	{		if(isEmpty()) {			throw new EmptyQueueException("The queue is empty");		}		T tempData = lastNode.data;		if(firstNode == lastNode) {			firstNode = null;			lastNode = null;			return tempData;					}		else {				lastNode = lastNode.previous;		return tempData;		}			} // end removeBack	public boolean isEmpty()	{		return firstNode == null;	} // end isEmpty		/**	* 	* The string is formed using the data from the front to the back of the deque.	* If a deque has the following data: Front-> Ava, Joe, Sarah, Robert <-Back then	* the toString should return a string "[Ava, Joe, Sarah, Robert]"	* It returns "[]" for an empty deque	* @return a string representing the content of the deque from the front to the back.	*/ 		public String toString(){	if(isEmpty()) {		return "[]";	}	else {		String megaString = "[";		DLNode current;		current = firstNode;		while(current != lastNode) {			megaString = megaString + current.data + ", ";			current = current.next;		}		megaString = megaString + current.data + "]";		return megaString;	}		}		private class DLNode	{		private T      data;  	 // Deque entry		private DLNode next;  	 // Link to next node		private DLNode previous; // Link to previous node		private DLNode(T data)		{			this.data = data;			next = null;				previous = null;			} // end constructor				private DLNode(DLNode previousNode, T data, DLNode nextNode)		{			this.data = data;			next = nextNode;				previous = previousNode;		} // end constructor				// You can add getters and setters for the other two references			} // end DLNode} // end LinkedDeque